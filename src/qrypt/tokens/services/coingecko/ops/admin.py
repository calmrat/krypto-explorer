# -*- coding: utf-8 -*-

"""
Qrypto - Token API - Ops - Pull Tokens

This module contains the operations for pulling tokens from the CoinGecko API.
"""

import asyncio

from sqlalchemy.exc import IntegrityError

# from sqlalchemy import insert, select, update
# from sqlalchemy.orm import Session
from qrypt.core.db import SessionLocal, get_db
from qrypt.core.log import logger as log
from qrypt.tokens.models import BlockchainPlatform, Token, get_all
from qrypt.tokens.services.coingecko.adapter import CoinGeckoAdapter
from qrypt.tokens.services.coingecko.config import CoinGeckoConfig
from qrypt.tokens.services.coingecko.schema import TokenOut


async def create_token(symbol: str, name: str, logo_url: str) -> None:
    """Create a new token in the database."""

    log.debug("Creating token with symbol: %s, name: %s", symbol, name)
    db = SessionLocal()  # create a session

    try:
        platforms = [BlockchainPlatform(name=f"{i}", symbol="{i}") for i in range(5)]
        new_token = Token(
            symbol=symbol, name=name, logo_url=logo_url, platforms=platforms
        )

        db.add(new_token)  # stage it for insertion
        db.commit()  # commit the transaction
        db.refresh(new_token)  # get autogenerated fields like `id`

        print("Inserted token with ID:", new_token.id)

    except Exception as e:
        db.rollback()  # roll back in case of error
        raise e

    finally:
        db.close()  # always close session


def pull_tokens() -> None:
    """Pull tokens from CoinGecko API and insert them into the database."""

    log.debug("Pulling tokens from CoinGecko API")
    config = CoinGeckoConfig()
    client = CoinGeckoAdapter(
        base_url=config.base_url, timeout=config.timeout, headers=config.headers
    )
    print(f"{client.base_url=}, {client.timeout=}, {client.headers=}")

    _tokens = asyncio.run(client.api.coins_list())

    if not _tokens:
        raise ValueError("No coins found in the response")

    log.debug("Found %d coins", len(_tokens))

    # Get a session
    db = next(get_db())

    # Prepare tokens for insertion
    skipped = []
    for token in _tokens:
        # all_tokens = get_all(Token)
        # log.debug("All tokens: %s", len(all_tokens))
        # log.debug("Token: %s", token["symbol"])
        # log.debug("platforms: %s", token.get("platforms", {}))

        _platforms = token.get("platforms", {})

        _platforms = [
            BlockchainPlatform(name=platform, address=address)
            for platform, address in _platforms.items()
        ]

        _token = Token(
            ext_id=str(token["id"]),
            symbol=str(token["symbol"]),
            name=str(token["name"]),
            platforms=_platforms,
            logo_url=token.get("image", "/static/images/coin-logo.png"),
        )
        # Let's track all the tokens, even if they are not added to the database

        db.add(_token)
        try:
            db.commit()
        except IntegrityError:
            log.debug(
                "⚠️ Token already exists, skipping: [%s] %s",
                _token.ext_id,
                _token.symbol,
            )
            db.rollback()
            # raise e
            skipped.append(_token)
            continue
        db.refresh(_token)

    # close the session
    db.close()

    log.debug("Inserted %d tokens", len(_tokens))
    log.debug("Skipped %d tokens", len(skipped))
